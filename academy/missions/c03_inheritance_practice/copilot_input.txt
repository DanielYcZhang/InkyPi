You are a strict grader helping a student learn inheritance and super().
Do not give the correct answer. Instead, ask probing questions to deepen understanding.

Evaluate this explanation using the rubric:
- Part 1: Answered questions about Vehicle/ElectricCar example (different from cards)
- Part 2: Explained line-specific code (Line 13, 18, etc.) with understanding
- Part 3: Comparison questions show deep thinking about inheritance
- Part 4: Transfer challenge completed (Weapon/Sword/Bow system designed)
- Part 5: Connected patterns back to C-03 mission code
- Shows understanding of inheritance and super(), not just memorization
- Uses plain language but demonstrates depth

For each item:
- Score 0 (missing), 1 (partial), or 2 (complete)
- If < 2, ask a question to guide deeper thinking
- Example: 'You mentioned super() but didn't explain WHY it prevents duplication. Can you elaborate?'

Here is the student's explanation:
============================================================
# Explain-Back (C-03)

## Part 1: New Example Code

Here's a different example using the same inheritance patterns you learned:

```python
class Vehicle:
    """Base class for all vehicles"""
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
    
    def display_info(self, draw, x, y):
        draw.text((x, y), f"Brand: {self.brand}", fill=(0,0,0))
        draw.text((x, y + 20), f"Model: {self.model}", fill=(0,0,0))

class ElectricCar(Vehicle):
    def __init__(self, brand, model, battery_range):
        super().__init__(brand, model)
        self.battery_range = battery_range
    
    def display_info(self, draw, x, y):
        super().display_info(draw, x, y)
        draw.text((x, y + 40), f"Range: {self.battery_range} km", fill=(0,0,0))
        draw.rectangle((x, y + 60, x + 100, y + 70), outline=(0,255,0), width=2)
        draw.text((x + 5, y + 62), "ELECTRIC", fill=(0,255,0))

class Motorcycle(Vehicle):
    def __init__(self, brand, model, engine_size):
        super().__init__(brand, model)
        self.engine_size = engine_size
    
    def display_info(self, draw, x, y):
        super().display_info(draw, x, y)
        draw.text((x, y + 40), f"Engine: {self.engine_size}cc", fill=(0,0,0))
```

---

## Part 2: Line-Specific Questions

**Line 2:** `"""Base class for all vehicles"""`
1. Why is this called a "base" class?
because it is the base and the other classes are based off it
2. What do you think `ElectricCar` and `Motorcycle` have in common with `Vehicle`?
they both have a brand and model

**Line 4:** `def __init__(self, brand, model):`
3. What is `__init__`? (Hint: Remember from C-02!)
it is the constructor for the class
4. Why does `Vehicle.__init__` only take `brand` and `model`, not battery info?
because it is the base class and the other classes are based off it, battery info is only used in the electric car class

**Line 13:** `super().__init__(brand, model)`
5. What does `super()` mean in this line?
we call super in this line because we want to use the __init__ method from the parent class
6. Why do we need to call `super().__init__(...)` instead of just setting `self.brand = brand` manually?
we need to call super() because we want to use the __init__ method from the parent class, this is better and easier than self.brand because it is less code and less easy to makeerrors
7. What would happen if you forgot this line and tried to access `self.brand` later?
if you frogot this line then you would get an error because the __init__ method from the parent class would not be called and you would not be able to access self.brand
**Line 18:** `super().display_info(draw, x, y)`
8. Is this calling the parent's method or the child's method? How do you know?
it is calling the parent's method because we are using super() and not self.display_info()
9. Why call `super().display_info(...)` BEFORE drawing the electric badge?
because we want to draw the electric badge after the brand and model text
10. If you swapped lines 18 and 19-20, what would change visually?
the electric badge would be drawn before the brand and model text
**Line 11:** `class ElectricCar(Vehicle):`
11. What does the `(Vehicle)` part mean?
it means that ElectricCar is a subclass of Vehicle
12. Does `ElectricCar` automatically have a `display_info` method even before line 17? Why?
it does because it is a subclass of Vehicle
**Line 20:** `draw.text((x, y + 40), f"Range: {self.battery_range} km", fill=(0,0,0))`
13. Why is this line at `y + 40` instead of `y + 20`?
because the brand and model text is drawn at y + 20
14. What does this tell you about what `super().display_info(...)` already drew?
it drew the brand and model text
---

## Part 3: Comparison Questions

15. Both `ElectricCar` and `Motorcycle` call `super().display_info(...)`. What code do they AVOID duplicating because of this?
they avoid duplicating the code for drawing the brand and model text

16. If you wanted to change the font color of the brand/model text for ALL vehicles, where would you make the change?
   - [ ] In `Vehicle.display_info`
   - [ ] In both `ElectricCar.display_info` and `Motorcycle.display_info`
   - Explain your answer: I would make a change in Vehicle.display_info because it is the base class and the other classes are based off it so the others will automatically update

17. Imagine adding a third vehicle: `class Truck(Vehicle)`. List what code you would need to write:
   ```python
   class Truck(Vehicle):
       def __init__(self, brand, model, payload_capacity):
           super().__init__(brand, model)
           self.payload_capacity = payload_capacity
       
       def display_info(self, draw, x, y):
           super().display_info(draw, x, y)
           draw.text((x, y + 40), f"Payload Capacity: {self.payload_capacity}kg", fill=(0,0,0))
   ```

---

## Part 4: Concept Transfer Challenge

18. Design a new inheritance system for a game:
   - **Base class**: `Weapon` (has `name` and `damage` properties)
   - **Subclass 1**: `Sword` (adds `blade_length` property)
   - **Subclass 2**: `Bow` (adds `arrow_count` property)
   
   Write the `__init__` method for `Sword` that uses `super()`:
   ```python
   class Sword(Weapon):
       def __init__(self, name, damage, blade_length):
           # Your code here
   ```

19. In 2-3 sentences, explain why using inheritance for `Sword` and `Bow` is better than creating two completely separate classes with no base class.
inheritence is better because they would have things in commond for example, how much damage they do or how durable they are. it is also better because it is less code and less easy to make errors.
---

## Part 5: C-03 Mission Connection

20. In `c03_inheritance_practice.py`, find where `super()` is called and write the line number: ___
?? theres lots of lines, this question is bad but line 86 has super() currently.

21. What would happen if you removed the `super().draw(...)` call from `PetCard`?
if you removed super().draw(...), then the title and border wouldn't be drawn

22. Reflection: You're building a game with 50 different enemy types. They all have health, position, and a draw method, but each enemy looks different. Would you use inheritance? Why or why not?
yes you should use inhertiance because it is less code due to the fact you can move the health stuff and less easy to make errors.
============================================================